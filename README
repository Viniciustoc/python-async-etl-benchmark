# ğŸš€ Benchmark: Python SÃ­ncrono vs AssÃ­ncrono em ETL

Este projeto visa demonstrar o impacto da arquitetura de software na performance de ingestÃ£o de dados (Data Ingestion), comparando paradigmas de I/O bloqueante e nÃ£o-bloqueante.

## ğŸ“Š Resultados do Benchmark

| Modelo | Tecnologia | Volume de Dados | Tempo de ExecuÃ§Ã£o |
| :--- | :--- | :--- | :--- |
| **SÃ­ncrono** | `requests` | 50 registros | ~50.0s |
| **AssÃ­ncrono** | `aiohttp` + `asyncio` | 200 registros | **~1.3s** |

> **ConclusÃ£o:** A abordagem assÃ­ncrona resultou em um aumento exponencial de vazÃ£o (throughput), sendo ~40x mais rÃ¡pida proporcionalmente.

## ğŸ› ï¸ Tecnologias Utilizadas
- **Python 3.10+**
- **Aiohttp / Aiofiles:** Para requisiÃ§Ãµes concorrentes e I/O nÃ£o-bloqueante.
- **Pandas:** Para estruturaÃ§Ã£o e exportaÃ§Ã£o dos dados (Excel/SQL).
- **SQLite:** PersistÃªncia dos metadados.

## ğŸ“‚ Estrutura do Projeto
- `/RoboHash_Sincrono`: ImplementaÃ§Ã£o linear tradicional.
- `/RoboHash_Assincono`: ImplementaÃ§Ã£o otimizada com Event Loop.

---
Desenvolvido por **Vinicius Stoc**